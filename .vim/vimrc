" Extend rather than replace Vim 8 defaults
source $VIMRUNTIME/defaults.vim

" Overrides for defaults.vim
unlet c_comment_strings

" Overrides for Git for Windows
set clipboard& wildmode& statusline&

" Main options
set hidden
set laststatus=2
set showmatch hlsearch shortmess-=S
set spell spellcapcheck=
set completeopt=menuone,popup
set backspace=indent,eol formatoptions+=j
set autoindent shiftwidth=0 tabstop=4
set ignorecase wildignorecase smartcase
set splitbelow splitright
set number relativenumber cursorline
set linebreak breakindent showbreak=â†³\ \ \ "
set colorcolumn=+1
set printoptions=formfeed:y

" Disable spellcheck for program-driven buffers and the preview window
autocmd BufWinEnter * if &buftype != '' | setlocal nospell | endif
autocmd WinEnter * if &previewwindow | set nospell | endif

" Make the fallback color scheme dark instead of light
if empty(v:termrbgresp) | set background=dark | endif

" No undercurl in Windows Terminal or iTerm2, so fallback to underline
set t_Cs=

" More traditional mouse behavior (click-drag, menus)
set mouse=a ttymouse=sgr mousemodel=popup_setpos

" More GUI-like behavior
set title belloff=all lazyredraw

" Improve responsiveness and disable swap files (save often!)
set updatetime=100 noswapfile

" Persistent undo tree
set undodir=~/.vim/undo undofile
call mkdir(&undodir, 'p', 0700)

" Continuous pane boundary
set fillchars+=vert:â”‚

" Mode-dependent cursor shape; assumes default (outside Vim) is blinking bar
set t_SI=[5\ q t_SR=[3\ q t_EI=[1\ q
autocmd VimLeave * set t_me=[5\ q

" Make equalalways actually work as advertised when the terminal is resized
autocmd VimResized * if &equalalways | wincmd = | endif

" Why isn't this default
nnoremap Y y$

" Shift-less command mode
noremap ; :
tnoremap <C-w>; <C-w>:

" More consistent history navigation
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>

" Quick save file without messing up timestamp
nnoremap <silent> , :<C-u>update<CR>

" Quick hide search result highlighting
nnoremap <silent> <BS> :<C-u>nohlsearch<CR>

" Speedy buffer switching
nnoremap <SPACE> <C-^>

" Speedy window switching
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Speedy window switching (consistent in terminal)
tnoremap <C-h> <C-w>h
tnoremap <C-j> <C-w>j
tnoremap <C-k> <C-w>k
tnoremap <C-l> <C-w>l

" Make :terminal easier to escape by assuming there's no TUI running
tnoremap <ScrollWheelUp> <C-w>N
tnoremap <ScrollWheelDown> <C-w>N
tnoremap <ScrollWheelLeft> <C-w>N
tnoremap <ScrollWheelRight> <C-w>N

" Show buffer menu and prompt
nnoremap <silent> <C-n> :<C-u>Buffers<CR>

" Alternative to GFiles: integrate with Fugitive to work better in edge cases
" Completion should actually be pathspec, not dir, but close enough
command -bang -nargs=* -complete=dir FugitiveFiles
\	call fzf#run(fzf#wrap('gfiles', fzf#vim#with_preview({
\		'source': FugitiveShellCommand('--no-literal-pathspecs', 'ls-files', '-z', '--', <f-args>),
\		'options': '--read0 --multi --no-clear --prompt=' . shellescape('FugitiveFiles> '),
\		'dir': FugitiveWorkTree(),
\	}), <bang>0))

" FZF in the current project (Git repo if present, otherwise whole directory)
nnoremap <expr> <silent> <C-p> FugitiveIsGitDir() ? ':<C-u>FugitiveFiles<CR>' : ':<C-u>Files<CR>'

" git grep without hit-enter prompt nor jumping to the first match
nnoremap <Leader>gg :<C-u>Ggrep! -q<SPACE>

" git grep (i.e. project-wide) analog of * (word search)
nnoremap <silent> <Leader>* :<C-u>Ggrep -q -w <cword> --<CR>
nnoremap <silent> <Leader>g* :<C-u>Ggrep -q <cword> --<CR>

" Auto-insert closing bracket for block
inoremap {<CR> {<CR>}<ESC>O

" Insert ASCII underline for headings
nnoremap _ yypVr=o<CR>

" Linter actions
nmap [r <Plug>(ale_previous)
nmap ]r <Plug>(ale_next)
nmap [R <Plug>(ale_first)
nmap ]R <Plug>(ale_last)

" Missing <Plug> mappings for ALE
nnoremap <unique> <silent> <Plug>(ale_find_references_quickfix) :<C-u>ALEFindReferences -quickfix \| cwindow<CR>
vnoremap <unique> <silent> <Plug>(ale_code_action) :ALECodeAction<CR>
nnoremap <unique> <silent> <Plug>(ale_organize_imports) :<C-u>ALEOrganizeImports<CR>

" IDE actions
autocmd User ALELSPStarted call s:ALELSPStarted()
function s:ALELSPStarted()
	nmap <buffer> K <Plug>(ale_hover)
	nmap <buffer> gK <Plug>(ale_documentation)
	nmap <buffer> <C-]> <Plug>(ale_go_to_definition)
	nmap <buffer> <C-w>] <C-w><C-]>
	nmap <buffer> <C-w><C-]> <Plug>(ale_go_to_definition_in_vsplit)
	nmap <buffer> g<C-]> <Plug>(ale_go_to_type_definition)
	nmap <buffer> <C-w>g] <C-w>g<C-]>
	nmap <buffer> <C-w>g<C-]> <Plug>(ale_go_to_type_definition_in_vsplit)
	nmap <buffer> - <Plug>(ale_find_references_quickfix)
	nmap <buffer> + <Plug>(ale_code_action)
	vmap <buffer> + <Plug>(ale_code_action)
	nmap <buffer> <F2> <Plug>(ale_rename)
	nmap <buffer> <S-F2> <Plug>(ale_file_rename)
	nmap <buffer> <Leader>i <Plug>(ale_import)
	nmap <buffer> <Leader>I <Plug>(ale_organize_imports)
	setlocal omnifunc=ale#completion#OmniFunc
endfunction

" IDE actions (project-wide)
nnoremap <Leader>s :<C-u>ALESymbolSearch -relative<SPACE>
nmap <Leader><Leader>s <Plug>(ale_repeat_selection)

" Useful built-in plugins
packadd! cfilter
packadd! matchit

" Don't need vinegar.vim for this :)
" Also helps to use :Explore rather than :e
let g:netrw_banner = 0

" Open links from WSL
if executable('wslview') | let g:netrw_browsex_viewer = 'wslview' | endif

" quick-scope plugin
let g:qs_lazy_highlight = 1

" traces plugin
let g:traces_preview_window = 'new'

" ALE language server plugin
let g:ale_fix_on_save = 1
let g:ale_lsp_suggestions = 1
let g:ale_completion_enabled = 1
let g:ale_set_balloons = 'hover'
let g:ale_echo_msg_format = '(%linter%) %code: %%s'

" Extend Vim's built-in output code detection for 24-bit color
if empty(&t_8f) && empty(&t_8b)
	set t_8f=[38;2;%lu;%lu;%lum
	set t_8b=[48;2;%lu;%lu;%lum
endif

" Detect 24-bit color according to https://gist.github.com/XVilka/8346728
if $COLORTERM =~? 'truecolor\|24bit' | set t_Co=16777216 | endif

" Use 24-bit color whenever available; the colorscheme MUST define GUI colors
if &t_Co >= 16777216 | set termguicolors | endif

" Color scheme that matches terminal (One Half Dark)
let g:one_allow_italics = 1
colorscheme one

" Without undercurl, color must be set manually (this is orange from One Dark)
call one#highlight('SpellBad', 'd19a66', '', '')
call one#highlight('SpellCap', 'd19a66', '', '')
call one#highlight('SpellLocal', 'd19a66', '', '')
call one#highlight('SpellRare', 'd19a66', '', '')
